---
# 当前页面内容标题
title: 大厂面试第三季预告片之雪花算法
# 分类
category:
  - springcloud
# 标签
tag: 
  - spring
  - springcloud
  - 微服务
  - java
sticky: false
# 是否收藏在博客主题的文章列表中，当填入数字时，数字越大，排名越靠前。
star: false
# 是否将该文章添加至文章列表中
article: true
# 是否将该文章添加至时间线中
timeline: true
---

## 01、大厂面试第三季预告片之雪花算法(上)

**为什么需要分布式全局唯一ID以及分布式ID的业务需求？集群高并发情况下如何保证分布式唯一全局Id生成？**

在复杂分布式系统中，往往需婴对大量的数据和消息进行唯一标识，如在美团点评的金融、支付、餐饮、酒店，猫眼电影等产品的系统中数据日渐增长，对数据分库分表后需要有一个唯一ID来标识一条数据或消息。特别一点的如订单、骑手、优惠券也都雷要有唯一ID做标识。此时一个能够生成全局唯一ID的系统是非常必要的。

**D生成规则部分硬性要求**

- *全局唯一*：不能出现重复的ID号，既然是唯一-标识，这是最基本的要求

- *趋势递增*：在MySQL的InnoDB引擎中使用的是聚集索引，由于多数RDBMS使用Btree的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。

- 单调递增：保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求

- 信息安全：如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可。如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，需要ID无规则不规则，让竞争对手否好猜。

- *含时间戳*：这样就能够在开发中快速了解这个分布式id的生成时间。

**ID号生成系统的可用性要求**

- *高可用*：发一个获取分布式ID的请求，服务器就要保证99.999%的情况下给我创建一个唯一分布式ID。
- *低延迟*：发一个获取分布式ID的请求，服务器就要快，极速。
- *高QPS*：假如并发一口气10万个创建分布式ID请求同时杀过来，服务器要顶的住且一下子成功创建10万个分布式ID。

**一般通用方案**

*UUID*

UUID(Universally Unique ldentifer)的标准型式包含32个16进制数字，以连了号分为五段，形式为8-4-4-4-12的36个字符， 示例：550e8400-e29b-41d4-a716-446655440000

性能非常高：本地生成，没有网络消耗

如果只是考虑唯一性，那就选用它吧

但是，入数据库性能差

**为什么无序的UUID会导致入库性能变差呢？**

1. 无序，无法预测他的生成顺序，不能生成递增有序的数字。首先分布式ID一般都会作为主键， 但是安装MySQL官方推荐主键要尽量越短越好，UUID每一个都很长，所以不是很推荐。

2. 主键，ID作为主键时在特定的环境会存在一些问题。比如做DB主键的场景下，UUID就非常不适用MySQL官方有明确的建议主键要尽量越短越好36个字符长度的UUID不符合要求。

3. 索引，既然分布式ID是主键，然后主键是包含索引的，然后MySQL的索引是通过B+树来实现的，每一次新的UUID数据的插入，为了查询的优化，都会对索引底层的B+树进行修改，因为UUID数据是无序的，所以每一次UUID数据的插入都会对主键地械的B+树进行很大的修改，这一点很不好。 插入完全无序，不但会导致一-些中间节点产生分裂，也会白白创造出很多不饱和的节点，这样大大降低了数据库插入的性能。

> All indexes other than the clustered index are known as [secondary indexes](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_secondary_index). In `InnoDB`, each record in a secondary index contains the primary key columns for the row, as well as the columns specified for the secondary index. `InnoDB` uses this primary key value to search for the row in the clustered index.
> 
> If the primary key is long, the secondary indexes use more space, so it is advantageous to have a short primary key.
> 
> [link](https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html)

**数据库自增主键**

*单机*

在单机里面，数据库的自增ID机制的主要原理是：数据库自增ID和MySQL数据库的replace into实现的。

REPLACE INTO的含义是插入一条记录，如果表中唯一索引的值遇到冲突，则替换老数据。

这里的replace into跟inset功能类似，不同点在于：replace into首先尝试插入数据列表中，如果发现表中已经有此行数据（根据主键或唯一索引判断）则先删除，再插入。否则直接插入新数据。

```sql
CREATE TABLE t_test(
    id BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    stub CHAR(1) NOT NULL DEFAULT '',
    UNIQUE KEY stub(stub)
)

SELECT * FROMt_ test;

REPLACE INTO t_test (stub) VALUES('b');

SELECT LAST_INSERT_ID();
```

*集群分布式*

那数据库自增ID机制适合作分布式ID吗？答案是不太适合

1：系统水平扩展比较困难，比如定义好了步长和机器台数之后，如果要添加机器该怎么做？假设现在只有一台机器发号是1，2，3，4，5（步长是1），这个时候需要扩容机器一台。可以这样做：把第二台机器的初始值设置得比第一台超过很多，貌似还好，现在想象一下如果我们线上有100台机器，这个时候要扩容该怎么做？简直是噩梦，所以系统水平扩展方案复杂难以实现。

2：数据库压力还是很大，每次获取ID都得读写一次数据库， 非常影响性能，不符合分布式ID里面的延迟低和要高QPS的规则（在高并发下，如果都去数据库里面获取id，那是非常影响性能的）

*基于Redis生成全局ID策略*

因为Redis是单线的天生保证原子性，可以使用原子操作INCR和INCRBY来实现

注意：在Redis集群情况下，同样和MySQL一样需要设置不同的增长步长，同时key一定要设置有效期可以使用Redis集群来获取更高的吞吐量。

假如一个集群中有5台Redis。可以初始化每台Redis的值分别是1,2,3,4,5，然后步长都是5。

各个Redis生成的ID为:

A：1, 6, 11, 16, 21

B：2, 7 , 12, 17, 22

C：3, 8, 13, 18, 23

D：4, 9, 14, 19, 24

E：5, 10, 15, 20, 25

## 02、大厂面试第三季预告片之雪花算法(下)

Twitter的分布式自增ID算法snowflake

概述

Twitter的snowflake解决了这种需求，最初Twitter把存储系统从MySQL迁移到Cassandra（由Facebook开发一套开源分布式NoSQL数据库系统）。因为Cassandra没有顺序ID生成机制，所以开发了这样一套全局唯一生成服务。

Twitter的分布式雪花算法SnowFlake ，经测试snowflake 每秒能够产生26万个自增可排序的ID

1. Twitter的SnowFlake生成ID能够按照时间有序生成。
2. SnowFlake算法生成ID的结果是一个64bit大小的整数， 为一个Long型（转换成字符串后长度最多19）。
3. 分布式系统内不会产生ID碰撞（由datacenter和workerld作区分）并且效率较高。

分布式系统中，有一些需要使用全局唯一ID的场景， 生成ID的基本要求：

1. 在分布式的环境下必须全局且唯一 。
2. 一般都需要单调递增，因为一般唯一ID都会存到数据库，而Innodb的特性就是将内容存储在主键索引树上的叶子节点而且是从左往右，递增的，所以考虑到数据库性能，一般生成的ID也最好是单调递增。 为了防止ID冲突可以使用36位的UUID，但是UUID有一些缺点， 首先他相对比较长， 另外UUID一般是无序的。
3. 可能还会需要无规则，因为如果使用唯一ID作为订单号这种，为了不然别人知道一天的订单量是多少，就需要这个规则。

**结构**

雪花算法的几个核心组成部分：

![img](./images/795b3d1fa01bbd15d8b7b85c2724bf42.png)

号段解析：

1bit：

不用，因为二进制中最高位是符号位，1表示负数，0表示正数。生成的id一般都是用整数，所以最高位固定为0。

41bit - 时间戳，用来记录时间戳，毫秒级：

- 41位可以表示2^41 -1个数字。
- 如果只用来表示正整数（计算机中正数包含0），可以表示的数值范围是：0至2^ 41 − 1，**减1是因为可表示的数值范围是从0开始算的，而不是1**。
- 也就是说41位可以表示`2^41`−1个毫秒的值，转化成单位年则是( 2^41 − 1 ) / ( 1000 ∗ 60 ∗ 60 ∗ 24 ∗ 365 ) = =69年。

10bit - 工作机器ID，用来记录工作机器ID：

- 可以部署在2^10 = =1024个节点，包括5位DataCenterId和5位Workerld。

- 5位(bit) 可以表示的最大正整数是2^5-1=31,即可以用0、1、2、3、…31这32个数字，来表示不同的DataCenterld或Workerld。

12bit - 序列号，用来记录同毫秒内产生的不同id。

- 12位(bit) 可以表示的最大正整数是2^12 − 1 = 4095， 即可以用0、1、2、 3、…4094这4095个数字，来表示同一机器同一时间截(毫秒)内产生的4095个ID序号。

SnowFlake可以保证：

- 所有生成的ID按时间趋势递增。
- 整个分布式系统内不会产生重复id（因为有DataCenterId和Workerld来做区分)

**源码**

以下代码仅供学习：

```java
/**
 * Twitter_Snowflake
 * SnowFlake的结构如下(每部分用-分开):
 * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000
 * 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0
 * 41位时间戳(毫秒级)，注意，41位时间戳不是存储当前时间的时间戳，而是存储时间戳的差值（当前时间戳 - 开始时间戳)
 * 得到的值），这里的的开始时间戳，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下面程序SnowflakeIdWorker类的startTime属性）。41位的时间戳，可以使用69年，年T = (1L << 41) / (1000L * 60 * 60 * 24 * 365) = 69
 * 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId
 * 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间戳)产生4096个ID序号
 * 加起来刚好64位，为一个Long型。
 */
public class SnowflakeIdWorker {
    /** 开始时间戳 (2015-01-01) */
    private final long twepoch = 1420041600000L;

    /** 机器id所占的位数 */
    private final long workerIdBits = 5L;

    /** 数据标识id所占的位数 */
    private final long datacenterIdBits = 5L;

    /** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */
    private final long maxWorkerId = -1L ^ (-1L << workerIdBits);

    /** 支持的最大数据标识id，结果是31 */
    private final long maxDatacenterId = -1L ^ (-1L << datacenterIdBits);

    /** 序列在id中占的位数 */
    private final long sequenceBits = 12L;

    /** 机器ID向左移12位 */
    private final long workerIdShift = sequenceBits;

    /** 数据标识id向左移17位(12+5) */
    private final long datacenterIdShift = sequenceBits + workerIdBits;

    /** 时间戳向左移22位(5+5+12) */
    private final long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;

    /** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */
    private final long sequenceMask = -1L ^ (-1L << sequenceBits);

    /** 工作机器ID(0~31) */
    private long workerId;

    /** 数据中心ID(0~31) */
    private long datacenterId;

    /** 毫秒内序列(0~4095) */
    private long sequence = 0L;

    /** 上次生成ID的时间戳 */
    private long lastTimestamp = -1L;

    //==============================Constructors=====================================
    /**
     * 构造函数
     * @param workerId 工作ID (0~31)
     * @param datacenterId 数据中心ID (0~31)
     */
    public SnowflakeIdWorker(long workerId, long datacenterId) {
        if (workerId > maxWorkerId || workerId < 0) {
            throw new IllegalArgumentException(String.format("worker Id can't be greater than %d or less than 0", maxWorkerId));
        }
        if (datacenterId > maxDatacenterId || datacenterId < 0) {
            throw new IllegalArgumentException(String.format("datacenter Id can't be greater than %d or less than 0", maxDatacenterId));
        }
        this.workerId = workerId;
        this.datacenterId = datacenterId;
    }

    // ==============================Methods==========================================
    /**
     * 获得下一个ID (该方法是线程安全的)
     * @return SnowflakeId
     */
    public synchronized long nextId() {
        long timestamp = timeGen();

        //如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常
        if (timestamp < lastTimestamp) {
            throw new RuntimeException(
                    String.format("Clock moved backwards.  Refusing to generate id for %d milliseconds", lastTimestamp - timestamp));
        }

        //如果是同一时间生成的，则进行毫秒内序列
        if (lastTimestamp == timestamp) {
            sequence = (sequence + 1) & sequenceMask;
            //毫秒内序列溢出
            if (sequence == 0) {
                //阻塞到下一个毫秒,获得新的时间戳
                timestamp = tilNextMillis(lastTimestamp);
            }
        }
        //时间戳改变，毫秒内序列重置
        else {
            sequence = 0L;
        }

        //上次生成ID的时间戳
        lastTimestamp = timestamp;

        //移位并通过或运算拼到一起组成64位的ID
        return ((timestamp - twepoch) << timestampLeftShift) //
                | (datacenterId << datacenterIdShift) //
                | (workerId << workerIdShift) //
                | sequence;
    }

    /**
     * 阻塞到下一个毫秒，直到获得新的时间戳
     * @param lastTimestamp 上次生成ID的时间戳
     * @return 当前时间戳
     */
    protected long tilNextMillis(long lastTimestamp) {
        long timestamp = timeGen();
        while (timestamp <= lastTimestamp) {
            timestamp = timeGen();
        }
        return timestamp;
    }

    /**
     * 返回以毫秒为单位的当前时间
     * @return 当前时间(毫秒)
     */
    protected long timeGen() {
        return System.currentTimeMillis();
    }

    /** 测试 */
    public static void main(String[] args) {
        System.out.println("开始："+System.currentTimeMillis());
        SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);
        for (int i = 0; i < 50; i++) {
            long id = idWorker.nextId();
            System.out.println(id);
//            System.out.println(Long.toBinaryString(id));
        }
        System.out.println("结束："+System.currentTimeMillis());
    }
}
```

**工程落地经验**

[Hutool的Snowflake文档](https://www.hutool.cn/docs/#/core/工具类/唯一ID工具-IdUtil?id=snowflake)

添加依赖

```xml
<dependency>
    <groupId>cn.hutool</groupId>
    <artifactId>hutool-captcha</artifactId>
    <version>4.6.8</version>
</dependency>
```

示例程序：

```java
import cn.hutool.core.lang.Snowflake;
import cn.hutool.core.net.NetUtil;
import cn.hutool.core.util.IdUtil; 
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;

@Slf4j
@Component
public class IdGeneratorSnowflake{
    private long workerId = 0;
    private long datacenterId = 1;
    private Snowflake snowflake = IdUtil.createSnowflake(workerId, datacenterId);

    public synchronized long snowflakeId(){
        return snowflake.nextId();
    }

    public synchronized long snowflakeId(long workerId, long datacenterId){
        Snowflake snowflake = IdUtil.createSnowflake(workerId, datacenterId);
        return snowflake.nextId();
    }

    public static void main(String[] args){
        IdGeneratorSnowflake idGenerator = new IdGeneratorSnowflake();
        System.out.println(idGenerator.snowflakeId());

        ExecutorService threadPool = Executors.newFixedThreadPool(5);
        for (int i = 1; i <= 20; i++){
            threadPool.submit(() -> {
                System.out.print1n(idGenerator.snowflakeId());
            });
        }

        threadPool.shutdown();

    }
}
```

**优缺点**

优点：

毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。

不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。

可以根据自身业务特性分配bit位，非常灵活。

缺点：

依赖机器时钟，如果机器时钟回拨，会导致重复ID生成。

在单机上是递增的，但是由于设计到分布式环境，每台机器上的时钟不可能完全同步，有时候会出现不是全局递增的情况。

（此缺点可以认为无所谓，一般分布式ID只要求趋势递增，并不会严格要求递增，90%的需求都只要求趋势递增）

**其他补充**

百度开源的分布式唯一ID生成器UidGenerator

美团点评分布式ID生成系统Leaf

## Spring Cloud组件总结

| 组件        | 简介                                                                                                                                                                                   | 分类               | 官网                                                                                                                                                      | 笔记                                                                                   | 备注                                         |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------ | ------------------------------------------ |
| Eureka    | Eureka is the Netflix Service Discovery Server and Client.                                                                                                                           | 服务注册中心           | [link](https://docs.spring.io/spring-cloud-netflix/docs/2.2.7.RELEASE/reference/html/#service-discovery-eureka-clients)                                 | [link](https://blog.csdn.net/u011863024/article/details/114298270#15_Eureka_1148)    | eureka中文解释：int.(因找到某物，尤指问题的答案而高兴)我发现了，我找到了 |
| Zookeeper | ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services.                           | 服务注册中心           | [link](https://zookeeper.apache.org/)                                                                                                                   | [link](https://blog.csdn.net/u011863024/article/details/107434932)                   | zookeeper中文解释：n.动物园管理员                     |
| Consul    | Consul is a service mesh solution providing a full featured control plane with service discovery, configuration, and segmentation functionality.                                     | 服务注册中心           | [link](https://www.consul.io/)                                                                                                                          | [link](https://blog.csdn.net/u011863024/article/details/114298270#31_Consul_2333)    | consul中文解释：n.领事                            |
| Ribbon    | Ribbon is a client-side load balancer that gives you a lot of control over the behavior of HTTP and TCP clients.                                                                     | 服务调用             | [link](https://docs.spring.io/spring-cloud-netflix/docs/2.2.7.RELEASE/reference/html/#spring-cloud-ribbon)                                              | [link](https://blog.csdn.net/u011863024/article/details/114298270#36_Ribbon_2780)    | ribbon中文解释：n.(用于捆绑或装饰的)带子;丝带;带状物;          |
| OpenFeign | Feign is a declarative web service client. It makes writing web service clients easier.                                                                                              | 服务调用             | [link](https://docs.spring.io/spring-cloud-openfeign/docs/2.2.7.RELEASE/reference/html/)                                                                | [link](https://blog.csdn.net/u011863024/article/details/114298270#43_OpenFeign_3304) | feign中文意思：v.假装，装作，佯装(有某种感觉或生病、疲倦等)         |
| Hystrix   | Netflix has created a library called Hystrix that implements the circuit breaker pattern.                                                                                            | 服务降级             | [link](https://docs.spring.io/spring-cloud-netflix/docs/2.2.7.RELEASE/reference/html/#circuit-breaker-spring-cloud-circuit-breaker-with-hystrix)        | [link](https://blog.csdn.net/u011863024/article/details/114298270#47_Hystrix_3696)   | hystrix中文意思：n.豪猪属;猬草属;豪猪;豪猪亚属              |
| GateWay   | Spring Cloud Gateway aims to provide a simple, yet effective way to route to APIs and provide cross  cutting concerns to them such as: security, monitoring/metrics, and resiliency. | 服务网关             | [link](https://docs.spring.io/spring-cloud-gateway/docs/2.2.7.RELEASE/reference/html/)                                                                  | [link](https://blog.csdn.net/u011863024/article/details/114298282#66_GateWay_771)    | gateway中文意思：n.网关;途径;门道;手段                  |
| Config    | Spring Cloud Config provides server-side and client-side support for externalized configuration in a distributed system.                                                             | 服务配置             | [link](https://docs.spring.io/spring-cloud-config/docs/2.2.7.RELEASE/reference/html/)                                                                   | [link](https://blog.csdn.net/u011863024/article/details/114298282#74_Config_1524)    | -                                          |
| Bus       | Spring Cloud Bus links nodes of a distributed system with a lightweight message broker.                                                                                              | 服务总线             | [link](https://docs.spring.io/spring-cloud-bus/docs/2.2.3.RELEASE/reference/html/)                                                                      | [link](https://blog.csdn.net/u011863024/article/details/114298282#78_Bus_2078)       | -                                          |
| Stream    | Spring Cloud Stream is a framework for building message-driven microservice applications.                                                                                            | 消息队列             | [link](https://docs.spring.io/spring-cloud-stream/docs/3.0.10.RELEASE/reference/html/spring-cloud-stream.html#spring-cloud-stream-overview-introducing) | [link](https://blog.csdn.net/u011863024/article/details/114298282#83_Stream_2576)    | -                                          |
| Sleuth    | Spring Cloud Sleuth implements a distributed tracing solution for Spring Cloud.                                                                                                      | 服务跟踪             | [link](https://docs.spring.io/spring-cloud-sleuth/docs/2.2.7.RELEASE/reference/html/)                                                                   | [link](https://blog.csdn.net/u011863024/article/details/114298282#92_Sleuth_3191)    | sleuth中文意思：n.侦探                            |
| Nacos     | Nacos致力于帮助您发现、配置和管理微服务。                                                                                                                                                              | 服务注册中心、服务配置、服务总线 | [link](https://nacos.io/zh-cn/docs/what-is-nacos.html)                                                                                                  | [link](https://blog.csdn.net/u011863024/article/details/114298282#96_Nacos_3488)     | NAme + COnfiguration + Service             |
| Sentinel  | Sentinel是面向分布式服务架构的流量控制组件，主要以流量为切入点，从流量控制、熔断降级、系统自适应保护等多个维度来帮助您保障微服务的稳定性。                                                                                                            | 服务降级             | [link](https://sentinelguard.io/zh-cn/docs/introduction.html)                                                                                           | [link](https://blog.csdn.net/u011863024/article/details/114298288#111_Sentinel_240)  | sentinel中文意思：n.哨兵                          |
| Seata     | Seata 是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。                                                                                                                                  | 分布式事务            | [link](https://seata.io/zh-cn/)                                                                                                                         | [link](https://blog.csdn.net/u011863024/article/details/114298288#139_Seata_2287)    | -                                          |
