---
# 当前页面内容标题
title: 六、Redis管道
# 分类
category:
  - redis
# 标签
tag: 
  - redis
  - NOSQL
  - K,V缓存数据库
  - 非关系型数据库
sticky: false
# 是否收藏在博客主题的文章列表中，当填入数字时，数字越大，排名越靠前。
star: false
# 是否将该文章添加至文章列表中
article: true
# 是否将该文章添加至时间线中
timeline: true
---

## 01、面试题

1. `如何优化频繁命令晚返造成的性能瓶颈？`

2. 问题由来？

```
Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。一个请求会遵循以下步骤：

1 客户端向服务端发送命令分四步(发送命令→命令排队→命令执行→返回结果)，并监听Socket返回，通常以阻塞模式等待服务端响应。

2 服务端处理命令，并将结果返回给客户端。

**上述两步称为：Round Trip Time(简称RTT,数据包往返于两端的时间)，问题笔记最下方**
```

![](./images/2023-03-30-21-07-58-image.png)

如果同时需要执行大量的命令，那么就要等待上一条命令应答后再执行，这中间不仅仅多了RTT（Round Time Trip），而且还频繁调用系统IO，发送网络请求，同时需要redis调用多次read()和write()系统方法，系统方法会将数据从用户态转移到内核态，这样就会对进程上下文有比较大的影响了，性能不太好，o(╥﹏╥)o

## 02、是什么？

### 解决思路

管道(pipeline)可以一次性发送多条命令给服务端，服务端依次处理完完毕后，通过一条响应一次性将结果返回，通过减少客户端与redis的通信次数来实现降低往返延时时间。pipeline实现的原理是队列，先进先出特性就保证数据的顺序性。

![](./images/2023-03-30-21-08-40-image.png)

> 引出管道这个概念

### 官网

> https://redis.io/docs/manual/pipelining/

### 定义

Pipeline是为了解决RTT往返回时，仅仅是将命令打包一次性发送，对整个Redis的执行不造成其他任意影响

### 一句话

批处理命令变种优化措施，类似Redis的原生批命令（mget和mset）

## 03、案例演示

- 当堂演示

![](./images/2023-03-30-21-13-21-image.png)

## 04、小总结

### Pieline与原生批量命令对比

- 原生批量命令是原子性（例如：mset、mget），`pipeline是非原子性`

- 原生批量命令一次只能执行一种命令，pipeline支持批量执行不同命令

- 原生批命令是服务端实现，而pipeline需要服务端与客户端共同完成

### Pipeline与事务的对比

- 事务具有原子性，管道不具有原子性

- 管道一次性价格多条命令发送到服务器，事务是一条一条的发，事务只有在接收到exec命令后才会执行，管道不会

- 执行事务时会阻塞其他命令的执行，而执行管道中的命令时不会

### 使用Pipeline注意事项

- pipeline缓冲的指令只是会依次执行，不保证原子性，如何执行中指令发生异常，将会继续执行后续的指令
- 使用pipeline组装的命令个数不能太多，不然数据量过大客户端阻塞的时间可能过久，同时服务端此时也被迫回复一个队列答复，占用很多内存！
